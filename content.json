{"meta":{"title":"韬光养月巴的技术博客","subtitle":"","description":"","author":"韬光养月巴","url":"http://blog.tgyf.com","root":"/"},"pages":[{"title":"Repositories","date":"2020-02-22T13:20:16.499Z","updated":"2020-02-22T12:01:21.689Z","comments":false,"path":"repository/index.html","permalink":"http://blog.tgyf.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-02-22T13:20:16.505Z","updated":"2020-02-22T12:01:21.688Z","comments":true,"path":"links/index.html","permalink":"http://blog.tgyf.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-22T13:20:16.510Z","updated":"2020-02-22T12:01:21.689Z","comments":false,"path":"tags/index.html","permalink":"http://blog.tgyf.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-02-22T13:20:16.515Z","updated":"2020-02-22T13:07:14.116Z","comments":false,"path":"categories/index.html","permalink":"http://blog.tgyf.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-02-22T13:20:16.520Z","updated":"2020-02-22T12:01:21.688Z","comments":false,"path":"books/index.html","permalink":"http://blog.tgyf.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-23T07:12:13.139Z","updated":"2020-02-23T07:12:13.092Z","comments":false,"path":"about/index.html","permalink":"http://blog.tgyf.com/about/index.html","excerpt":"","text":"欢迎访问我的博客，我会保持不定期更新。 123456789101112131415161718192021222324252627282930313233343536 _______ ______ __ __ _____ /\\_______)\\/_/\\___\\/\\ /\\ /\\ /\\_____\\ \\(___ __\\/) ) ___/\\ \\ \\/ / /( ( ___/ / / / /_/ / ___\\ \\__/ / \\ \\ \\_ ( ( ( \\ \\ \\_/\\__\\\\__/ / / / /_\\ \\ \\ \\ )_) \\/ _// / / / /____/ /_/_/ \\_\\____/ \\/_/ \\/_/ &#123; \"name\": \"韬光养月巴\", \"age\": 30, \"gender\": \"男\", \"profession\": \"Java Developer &amp; Designer\", \"experience\": \"5年\", \"address\": \"四川省成都市\", \"education\": \"本科\", \"github\": \"https://github.com/tgyf\", \"blog\": \"http://blog.tgyf.com\", \"email\": \"back_up[a]foxmail.com\", \"skills\":[ [\"SpringFramework\", \"Netty\", \"Dubbo\", \"Mybatis\"], [\"Html\", \"Javascript\", \"jQuery\", \"CSS\"], [\"Mysql\",\"Orcal\",\"Redis\",\"MongoDB\"], [\"Docker\", \"Swarm\",\"K8s\"], [\"Git\", \"SVN\"], ], \"devTools\":[ [\"IntelliJ IDEA \", \"VisualStudioCode\", \"Notepad++\"], [\"SourceTree\", \"TortoiseSVN\"], [\"Navicat\", \"RedisDesktopManager\",\"Robo3t\"], [\"MobaXterm\",\"Xshell\"] ] &#125;"},{"title":"404 Not Found：该页无法显示","date":"2020-02-22T13:20:16.531Z","updated":"2020-02-22T12:01:21.685Z","comments":false,"path":"/404.html","permalink":"http://blog.tgyf.com/404.html","excerpt":"","text":""}],"posts":[{"title":"RabbitMQ（四） - 优先级队列(PriorityQueue)","slug":"Middleware/RabbitMQ/RabbitMQ-PriorityQueue","date":"2020-02-24T15:11:23.490Z","updated":"2020-02-24T15:11:23.490Z","comments":true,"path":"2020/02/24/Middleware/RabbitMQ/RabbitMQ-PriorityQueue/","link":"","permalink":"http://blog.tgyf.com/2020/02/24/Middleware/RabbitMQ/RabbitMQ-PriorityQueue/","excerpt":"","text":"RabbitMQ - 优先级队列(PriorityQueue) 在RabbitMQ中使用优先级特性需要的版本为3.5+。 使用优先级特性只需做两件事情： 1. 将队列声明为优先级队列，即在创建队列的时候添加参数 x-max-priority 以指定最大的优先级，值为0-255（整数）。 2. 为优先级消息添加优先级。 注意:没有指定优先级的消息会将优先级以0对待。 对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待。对于相同优先级的消息，后进的排在前面。 核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.tgyf.rabbit.config;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.HashMap;import java.util.Map;/** * direct exchange -- 直接交换器 * 发送到该交换器的消息都会被路由到与 routing key 匹配的队列中 * @author 韬光养月巴 * @modify * @createDate 2019/8/24 1:29 PM * @remark */@Configuration@Slf4jpublic class DirectExchangeConf &#123; public static final String QUEUE = \"direct-queue-priority\"; public static final String EXCHANGE = \"exchange-direct\"; public static final String ROUTING_KEY = \"direct.queue.priority\"; @Bean Queue directQueuePriority() &#123; //创建队列的时候添加参数 x-max-priority 以指定最大的优先级，值为0-255 Map&lt;String, Object&gt; args= new HashMap&lt;&gt;(); args.put(\"x-max-priority\", 100); return new Queue(QUEUE, false, false, false, args); &#125; @Bean DirectExchange directExchange() &#123; return new DirectExchange(EXCHANGE); &#125; @Bean Binding directQueuePriorityBinding(Queue directQueuePriority, DirectExchange directExchange) &#123; return BindingBuilder.bind(directQueuePriority).to(directExchange).with(ROUTING_KEY); &#125;&#125; 测试 1.测试优先级队列 发送优先级低的消息 100 条到 RabbitMQ curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-direct&quot;, &quot;routingKey&quot;: &quot;direct.queue.priority&quot;, &quot;priority&quot;: 1, &quot;content&quot;:&quot; hello priority queue! &quot;, &quot;count&quot;: 100 }' 发送优先级高的消息 5 条到 RabbitMQ curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-direct&quot;, &quot;routingKey&quot;: &quot;direct.queue.priority&quot;, &quot;priority&quot;: 10, &quot;content&quot;:&quot; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; hello priority queue! &quot;, &quot;count&quot;: 5 }'","categories":[{"name":"中间件","slug":"中间件","permalink":"http://blog.tgyf.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/categories/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.tgyf.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.tgyf.com/tags/RabbitMQ/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/tags/MQ/"}]},{"title":"RabbitMQ（二） - 交换器（Exchange）","slug":"Middleware/RabbitMQ/RabbitMQ-Exchang","date":"2020-02-24T15:11:16.763Z","updated":"2020-02-24T15:11:16.763Z","comments":true,"path":"2020/02/24/Middleware/RabbitMQ/RabbitMQ-Exchang/","link":"","permalink":"http://blog.tgyf.com/2020/02/24/Middleware/RabbitMQ/RabbitMQ-Exchang/","excerpt":"","text":"RabbitMQ - 交换器（Exchange） 交换器名称 作用 fanout exchange 发送到该交换器的所有消息，会被路由到其绑定的所有队列 direct exchange 发送到该交换器的消息，会通过路由键完全匹配，匹配成功就会路由到指定队列 topic exchange 发送到该交换器的消息，会通过路由键模糊匹配，匹配成功就会路由到指定队列 header exchange 发送到该交换器的消息，会通过消息的 header 信息匹配，匹配成功就会路由到指定队列 核心代码 pom.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.tgyf.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;exchange&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; direct exchange – 直接交换器 发送到该交换器的消息都会被路由到与 routing key 匹配的队列中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.tgyf.rabbit.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * direct exchange -- 直接交换器 * 发送到该交换器的消息都会被路由到与 routing key 匹配的队列中 * @author 韬光养月巴 * @modify * @createDate 2019/8/24 12:07 PM * @remark */@Configurationpublic class DirectExchangeConf &#123; public static final String QUEUE_1 = \"direct-queue-1\"; public static final String QUEUE_2 = \"direct-queue-2\"; private static final String EXCHANGE = \"exchange-direct\"; private static final String ROUTING_KEY_TO_QUEUE1 = \"queue.direct.key1\"; private static final String ROUTING_KEY_TO_QUEUE2 = \"queue.direct.key2\"; @Bean Queue directQueue1() &#123; return new Queue(QUEUE_1, false); &#125; @Bean Queue directQueue2() &#123; return new Queue(QUEUE_2, false); &#125; @Bean DirectExchange directExchange() &#123; return new DirectExchange(EXCHANGE); &#125; @Bean Binding bindingDirectQueue1(Queue directQueue1, DirectExchange directExchange) &#123; return BindingBuilder.bind(directQueue1).to(directExchange).with(ROUTING_KEY_TO_QUEUE1); &#125; @Bean Binding bindingDirectQueue2(Queue directQueue2, DirectExchange directExchange) &#123; return BindingBuilder.bind(directQueue2).to(directExchange).with(ROUTING_KEY_TO_QUEUE2); &#125;&#125; fanout exchange – 扇出交换器 所有发送到该交换器的消息都会被路由到所有与该交换器绑定的队列中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.tgyf.rabbit.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * fanout exchange -- 扇出交换器 * 所有发送到该交换器的消息都会被路由到所有与该交换器绑定的队列中 * @author 韬光养月巴 * @modify * @createDate 2019/8/24 12:04 PM * @remark */@Configurationpublic class FanoutExchangeConf &#123; public static final String QUEUE_1 = \"fanout-queue-1\"; public static final String QUEUE_2 = \"fanout-queue-2\"; private static final String EXCHANGE = \"exchange-fanout\"; @Bean Queue fanoutQueue1() &#123; return new Queue(QUEUE_1, false); &#125; @Bean Queue fanoutQueue2() &#123; return new Queue(QUEUE_2, false); &#125; @Bean FanoutExchange fanoutExchange() &#123; return new FanoutExchange(EXCHANGE); &#125; @Bean Binding bindingFanoutQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); &#125; @Bean Binding bindingFanoutQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); &#125;&#125; headers exchange – headers交换器 发送到该交换器的消息会根据消息的 header 信息路由到对应的队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.tgyf.rabbit.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.HeadersExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;/** * headers exchange -- headers交换器 * 发送到该交换器的消息会根据消息的 header 信息路由到对应的队列 * 说明： * where 匹配单个 header * whereAll 同时匹配多个 header * whereAny 匹配一个或多个 header * * @author 韬光养月巴 * @modify * @createDate 2019/8/24 12:12 PM * @remark */public class HeadersExchangeConf &#123; public static final String QUEUE_1 = \"headers-queue-1\"; public static final String QUEUE_2 = \"headers-queue-2\"; public static final String QUEUE_3 = \"headers-queue-3\"; private static final String EXCHANGE = \"exchange-headers\"; @Bean Queue headersQueue1() &#123; return new Queue(QUEUE_1, false); &#125; @Bean Queue headersQueue2() &#123; return new Queue(QUEUE_2, false); &#125; @Bean Queue headersQueue3() &#123; return new Queue(QUEUE_3, false); &#125; @Bean HeadersExchange headersExchange() &#123; return new HeadersExchange(EXCHANGE); &#125; @Bean Binding bindingHeadersQueue1(Queue headersQueue1, HeadersExchange headersExchange) &#123; return BindingBuilder.bind(headersQueue1).to(headersExchange).where(\"one\").exists(); &#125; @Bean Binding bindingHeadersQueue2(Queue headersQueue1, HeadersExchange headersExchange) &#123; return BindingBuilder.bind(headersQueue1).to(headersExchange).whereAll(\"all1\", \"all2\").exist(); &#125; @Bean Binding bindingHeadersQueue3(Queue headersQueue3, HeadersExchange headersExchange) &#123; return BindingBuilder.bind(headersQueue3).to(headersExchange).whereAny(\"any1\", \"any2\").exist(); &#125;&#125; topic exchange – 主题交换器 发送到该交换器的消息都会被路由到与 routing key 匹配的队列中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.tgyf.rabbit.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * topic exchange -- 主题交换器 * 发送到该交换器的消息都会被路由到与 routing key 匹配的队列中 * 说明： * routing key 以 '.' 分隔为多个单词 * routing key 以 '*' 匹配一个单词 * routing key 以 '#' 匹配零个或多个单词 * 例如： * queue.topic.key -&gt; QUEUE_1 + QUEUE_2 * test.topic.key -&gt; QUEUE_1 * queue -&gt; QUEUE_2 * queue.topic -&gt; QUEUE_2 * * @author 韬光养月巴 * @modify * @createDate 2019/8/24 12:09 PM * @remark */@Configurationpublic class TopicExchangeConf &#123; public static final String QUEUE_1 = \"topic-queue-1\"; public static final String QUEUE_2 = \"topic-queue-2\"; private static final String EXCHANGE = \"exchange-topic\"; private static final String ROUTING_KEY_TO_QUEUE1 = \"*.topic.*\"; private static final String ROUTING_KEY_TO_QUEUE2 = \"queue.#\"; @Bean Queue topicQueue1() &#123; return new Queue(QUEUE_1, false); &#125; @Bean Queue topicQueue2() &#123; return new Queue(QUEUE_2, false); &#125; @Bean TopicExchange topicExchange() &#123; return new TopicExchange(EXCHANGE); &#125; @Bean Binding bindingTopicQueue1(Queue topicQueue1, TopicExchange topicExchange) &#123; return BindingBuilder.bind(topicQueue1).to(topicExchange).with(ROUTING_KEY_TO_QUEUE1); &#125; @Bean Binding bindingTopicQueue2(Queue topicQueue2, TopicExchange topicExchange) &#123; return BindingBuilder.bind(topicQueue2).to(topicExchange).with(ROUTING_KEY_TO_QUEUE2); &#125;&#125; 测试 1.测试fanout exchange curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-fanout&quot;, &quot;routingKey&quot;: &quot;default&quot;, &quot;content&quot;:&quot; hello fanout!&quot;, &quot;count&quot;: 1 }' 2.测试 direct exchange curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-direct&quot;, &quot;routingKey&quot;: &quot;queue.direct.key1&quot;, &quot;content&quot;:&quot; hello direct! &quot;, &quot;count&quot;: 1 }' curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-direct&quot;, &quot;routingKey&quot;: &quot;queue.direct.key2&quot;, &quot;content&quot;:&quot; hello direct! &quot;, &quot;count&quot;: 1 }' 3.测试 topic exchange curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-topic&quot;, &quot;routingKey&quot;: &quot;queue.topic.key1&quot;, &quot;content&quot;:&quot; hello topic! &quot;, &quot;count&quot;: 1 }' curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-topic&quot;, &quot;routingKey&quot;: &quot;test.topic.key2&quot;, &quot;content&quot;:&quot; hello topic! &quot;, &quot;count&quot;: 1 }' curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-topic&quot;, &quot;routingKey&quot;: &quot;queue.hello&quot;, &quot;content&quot;:&quot; hello topic! &quot;, &quot;count&quot;: 1 }' 4.测试 headers exchange curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-headers&quot;, &quot;content&quot;:&quot; hello headers! &quot;, &quot;count&quot;: 1, &quot;headers&quot;:{ &quot;one&quot;:&quot;value&quot; } }' curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-headers&quot;, &quot;content&quot;:&quot; hello headers! &quot;, &quot;count&quot;: 1, &quot;headers&quot;:{ &quot;all1&quot;:&quot;value&quot;, &quot;all2&quot;:&quot;value&quot; } }' curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-headers&quot;, &quot;content&quot;:&quot; hello headers! &quot;, &quot;count&quot;: 1, &quot;headers&quot;:{ &quot;any2&quot;:&quot;value&quot;, } }'","categories":[{"name":"中间件","slug":"中间件","permalink":"http://blog.tgyf.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/categories/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.tgyf.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.tgyf.com/tags/RabbitMQ/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/tags/MQ/"}]},{"title":"RabbitMQ（三） - 死信队列(DeadLetterQueue)","slug":"Middleware/RabbitMQ/RabbitMQ-DeadletterQueue","date":"2020-02-24T15:11:10.610Z","updated":"2020-02-24T15:11:10.611Z","comments":true,"path":"2020/02/24/Middleware/RabbitMQ/RabbitMQ-DeadletterQueue/","link":"","permalink":"http://blog.tgyf.com/2020/02/24/Middleware/RabbitMQ/RabbitMQ-DeadletterQueue/","excerpt":"","text":"RabbitMQ - 死信队列(DeadLetterQueue) 什么是死信 “死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况： 1.消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue 属性被设置为false。 2.消息在队列的存活时间超过设置的TTL时间。 3.消息队列的消息数量已经超过最大队列长度。 那么该消息将成为“死信”。 “死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。 死信生命周期 死信队列只是一个绑定在死信交换机上的普通队列，而死信交换机也只是一个普通的交换机，不过是用来专门处理死信的交换机。 死信的生命周期： 业务消息被投入业务队列 消费者消费业务队列的消息，由于处理过程中发生异常，于是进行了nck或者reject操作 被nck或reject的消息由RabbitMQ投递到死信交换机中 死信交换机将消息投入相应的死信队列 死信队列的消费者消费死信消息 死信消息是RabbitMQ为我们做的一层保证，其实我们也可以不使用死信队列，而是在消息消费异常时，将消息主动投递到另一个交换机中，关键在于这些Exchange和Queue怎么配合。比如从死信队列拉取消息，然后发送邮件、短信、钉钉通知来通知开发人员关注。或者将消息重新投递到一个队列然后设置过期时间，来进行延时消费。 死信消息的Header 字段名 含义 x-first-death-exchange 第一次被抛入的死信交换机的名称 x-first-death-reason 第一次成为死信的原因，rejected：消息在重新进入队列时被队列拒绝，由于default-requeue-rejected 参数被设置为false。expired ：消息过期。maxlen ： 队列内消息数量超过队列最大容量 x-first-death-queue 第一次成为死信前所在队列名称 x-death 历次被投入死信交换机的信息列表，同一个消息每次进入一个死信交换机，这个数组的信息就会被更新 死信队列应用场景 一般用在较为重要的业务队列中，确保未被正确消费的消息不被丢弃，一般发生消费异常可能原因主要有由于消息信息本身存在错误导致处理异常，处理过程中参数校验异常，或者因网络波动导致的查询异常等等，当发生异常时，当然不能每次通过日志来获取原消息，然后让运维帮忙重新投递消息（没错，以前就是这么干的= =）。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了。 核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.tgyf.rabbit.config;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 死信交换器 * * @author 韬光养月巴 * @modify * @createDate 2019/8/24 2:18 PM * @remark */@Configuration@Slf4jpublic class DeadLetterExchangeConf &#123; public static final String QUEUE_BY_MAX_LENGTH = \"direct-queue-dead-by-max-length\"; public static final String QUEUE_BY_TTL = \"direct-queue-dead-by-ttl\"; public static final String QUEUE_BY_REJECT = \"direct-queue-dead-by-reject\"; public static final String EXCHANGE = \"exchange-direct-dead\"; public static final String ROUTING_KEY_BY_MAX_LENGTH = \"direct.queue.dead.max.length\"; public static final String ROUTING_KEY_BY_TTL = \"direct.queue.dead.ttl\"; public static final String ROUTING_KEY_BY_REJECT = \"direct.queue.dead.reject\"; @Bean Queue deadByMaxLengthQueue() &#123; return new Queue(QUEUE_BY_MAX_LENGTH, false); &#125; @Bean Queue deadByTTLQueue() &#123; return new Queue(QUEUE_BY_TTL, false); &#125; @Bean Queue deadByRejectQueue() &#123; return new Queue(QUEUE_BY_REJECT, false); &#125; @Bean DirectExchange deadDirectExchange() &#123; return new DirectExchange(EXCHANGE); &#125; @Bean Binding deadByMaxLengthQueueBinding(Queue deadByMaxLengthQueue, DirectExchange deadDirectExchange) &#123; return BindingBuilder.bind(deadByMaxLengthQueue).to(deadDirectExchange).with(ROUTING_KEY_BY_MAX_LENGTH); &#125; @Bean Binding deadByTTLQueueBinding(Queue deadByTTLQueue, DirectExchange deadDirectExchange) &#123; return BindingBuilder.bind(deadByTTLQueue).to(deadDirectExchange).with(ROUTING_KEY_BY_TTL); &#125; @Bean Binding deadByRejectQueueBinding(Queue deadByRejectQueue, DirectExchange deadDirectExchange) &#123; return BindingBuilder.bind(deadByRejectQueue).to(deadDirectExchange).with(ROUTING_KEY_BY_REJECT); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.tgyf.rabbit.config;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.HashMap;import java.util.Map;/** * 普通交换器 * * @author 韬光养月巴 * @modify * @createDate 2019/8/24 2:18 PM * @remark */@Configuration@Slf4jpublic class DirectExchangeConf &#123; public static final String QUEUE_MAX_LENGTH = \"direct-queue-max-length\"; public static final String QUEUE_TTL = \"direct-queue-ttl\"; public static final String QUEUE_REJECT = \"direct-queue-reject\"; public static final String EXCHANGE = \"exchange-direct\"; public static final String ROUTING_KEY_MAX_LENGTH = \"direct.queue.max.length\"; public static final String ROUTING_KEY_TTL = \"direct.queue.ttl\"; public static final String ROUTING_KEY_REJECT = \"direct.queue.reject\"; @Bean Queue maxLengthQueue() &#123; Map&lt;String, Object&gt; args= new HashMap&lt;&gt;(); // 设置队列最大长度 args.put(\"x-max-length\", 10); // 设置死信转发的 exchange 和 routing key args.put(\"x-dead-letter-exchange\", DeadLetterExchangeConf.EXCHANGE); args.put(\"x-dead-letter-routing-key\", DeadLetterExchangeConf.ROUTING_KEY_BY_MAX_LENGTH); return new Queue(QUEUE_MAX_LENGTH, false, false, false, args); &#125; @Bean Queue ttlQueue() &#123; Map&lt;String, Object&gt; args= new HashMap&lt;&gt;(); // 设置消息存活时间 10s args.put(\"x-message-ttl\", 10000); // 设置死信转发的 exchange 和 routing key args.put(\"x-dead-letter-exchange\", DeadLetterExchangeConf.EXCHANGE); args.put(\"x-dead-letter-routing-key\", DeadLetterExchangeConf.ROUTING_KEY_BY_TTL); return new Queue(QUEUE_TTL, false, false, false, args); &#125; @Bean Queue rejectQueue() &#123; Map&lt;String, Object&gt; args= new HashMap&lt;&gt;(); // 设置死信转发的 exchange 和 routing key args.put(\"x-dead-letter-exchange\", DeadLetterExchangeConf.EXCHANGE); args.put(\"x-dead-letter-routing-key\", DeadLetterExchangeConf.ROUTING_KEY_BY_REJECT); return new Queue(QUEUE_REJECT, false, false, false, args); &#125; @Bean DirectExchange directExchange() &#123; return new DirectExchange(EXCHANGE); &#125; @Bean Binding maxLengthQueueBinding(Queue maxLengthQueue, DirectExchange directExchange) &#123; return BindingBuilder.bind(maxLengthQueue).to(directExchange).with(ROUTING_KEY_MAX_LENGTH); &#125; @Bean Binding ttlQueueBinding(Queue ttlQueue, DirectExchange directExchange) &#123; return BindingBuilder.bind(ttlQueue).to(directExchange).with(ROUTING_KEY_TTL); &#125; @Bean Binding rejectQueueBinding(Queue rejectQueue, DirectExchange directExchange) &#123; return BindingBuilder.bind(rejectQueue).to(directExchange).with(ROUTING_KEY_REJECT); &#125;&#125; 测试 1.测试消费者否认消息 curl -X POST \\ http://127.0.0.1:8080/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-direct&quot;, &quot;routingKey&quot;: &quot;direct.queue.reject&quot;, &quot;content&quot;:&quot; hello reject queue! &quot;, &quot;count&quot;: 1 }' 2.测试消息超出队列最大长度 curl -X POST \\ http://127.0.0.1:8080/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-direct&quot;, &quot;routingKey&quot;: &quot;direct.queue.max.length&quot;, &quot;content&quot;:&quot; hello max length queue! &quot;, &quot;count&quot;: 30 }' 提示：消息队列遵循先进先出的策略，假设队列最大长度设置为 10，发送 30 条消息到该队列，若无消费者，前 20 条消息会被转发到指定的其他队列，后 10 条会保存在该队列中，除非有新的消息入队，这 10 条消息才会被转发 3.测试消息超时 curl -X POST \\ http://127.0.0.1:8080/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-direct&quot;, &quot;routingKey&quot;: &quot;direct.queue.ttl&quot;, &quot;content&quot;:&quot; hello ttl queue! &quot;, &quot;count&quot;: 10 }' 4.测试延迟队列 curl -X POST \\ http://127.0.0.1/send \\ -H 'Content-Type: application/json' \\ -d '{ &quot;exchange&quot;:&quot;exchange-direct&quot;, &quot;routingKey&quot;: &quot;direct.queue.delay&quot;, &quot;content&quot;:&quot; hello delay delay! &quot;, &quot;count&quot;: 1, &quot;delayTime&quot;: &quot;10000&quot; }'","categories":[{"name":"中间件","slug":"中间件","permalink":"http://blog.tgyf.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/categories/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.tgyf.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.tgyf.com/tags/RabbitMQ/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/tags/MQ/"}]},{"title":"RabbitMQ（一） - 配置详解","slug":"Middleware/RabbitMQ/RabbitMQ","date":"2020-02-24T15:10:50.667Z","updated":"2020-02-24T15:10:50.667Z","comments":true,"path":"2020/02/24/Middleware/RabbitMQ/RabbitMQ/","link":"","permalink":"http://blog.tgyf.com/2020/02/24/Middleware/RabbitMQ/RabbitMQ/","excerpt":"","text":"启动 RabbitMQ docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -v `pwd`/data:/var/lib/rabbitmq --hostname rabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:3.7-management-plugins 构建RabbitMQ镜像参考RabbitMQ 镜像dockerfile 内容结构 序号 内容名称 内容说明 1 exchange 交换器 2 priorityqueue 优先级队列 3 deadletterqueue 死信队列 Spring Boot RabbitMQ 参数配置详解 连接配置 spring.rabbitmq.host=localhost # RabbitMQ 地址 spring.rabbitmq.port=5672 # RabbitMQ 端口 spring.rabbitmq.username=guest # RabbitMQ 用户名 spring.rabbitmq.password=guest # RabbitMQ 密码 spring.rabbitmq.addresses= # 设置 RabbitMQ 集群，多个地址使用 &quot;,&quot; 分隔，例如：192.168.0.100:5672,192.168.0.101:5672 spring.rabbitmq.virtual-host= # 设置 Virtual Host spring.rabbitmq.ssl.algorithm= # SSL 算法，默认情况下，由 Rabbit 客户端配置 spring.rabbitmq.ssl.enabled=false # 是否启用 SSL 支持 spring.rabbitmq.ssl.key-store= # key 存储路径 spring.rabbitmq.ssl.key-store-password= # 用于访问 key 的密码 spring.rabbitmq.ssl.key-store-type=PKCS12 # Key 存储类型 spring.rabbitmq.ssl.trust-store= # Trust 存储路径 spring.rabbitmq.ssl.trust-store-password= # 用于访问 Trust 的密码 spring.rabbitmq.ssl.trust-store-type=JKS # Trust 存储类型 spring.rabbitmq.ssl.validate-server-certificate=true # 是否启用服务端证书验证 spring.rabbitmq.ssl.verify-hostname=true # 是否启用 hostname 验证 Publisher 配置 spring.rabbitmq.publisher-confirms=false # 是否启用 publisher 确认 spring.rabbitmq.publisher-returns=false # 是否启用 publisher 返回 spring.rabbitmq.template.default-receive-queue= # 没有没确定指定队列时的默认队列 spring.rabbitmq.template.exchange= # 发送消息默认的 exchange spring.rabbitmq.template.mandatory= # 是否启用 mandatory 消息 spring.rabbitmq.template.receive-timeout= # `receive()` 操作的超时时间 spring.rabbitmq.template.reply-timeout= # `sendAndReceive()` 操作的超时时间 spring.rabbitmq.template.retry.enabled=false # 是否启用重试 spring.rabbitmq.template.retry.initial-interval=1000ms # 两次重试间的时间间隔 spring.rabbitmq.template.retry.max-attempts=3 # 最大重试次数 spring.rabbitmq.template.retry.max-interval=10000ms # 最长重试时间 spring.rabbitmq.template.retry.multiplier=1 # Multiplier to apply to the previous retry interval. spring.rabbitmq.template.routing-key= # 发送消息默认的 routing key Consumer 设置 spring.rabbitmq.listener.direct.acknowledge-mode= # 确认模式：auto / manual / none spring.rabbitmq.listener.direct.auto-startup=true # 是否在应用启动时自动启动容器 spring.rabbitmq.listener.direct.consumers-per-queue= # 每个队列的消费者数量 spring.rabbitmq.listener.direct.default-requeue-rejected= # 默认情况下，拒收的消息是否重新排队 spring.rabbitmq.listener.direct.idle-event-interval= # 空闲容器事件发布的频率 spring.rabbitmq.listener.direct.missing-queues-fatal=false # 如果容器声明的队列在 broker 上不可用，是否失败 spring.rabbitmq.listener.direct.prefetch= # 预加载的消息数量 spring.rabbitmq.listener.direct.retry.enabled=false # 是否启用发布重试 spring.rabbitmq.listener.direct.retry.initial-interval=1000ms # 两次重试时间间隔 spring.rabbitmq.listener.direct.retry.max-attempts=3 # 最大重试次数 spring.rabbitmq.listener.direct.retry.max-interval=10000ms # 最长重试时间 spring.rabbitmq.listener.direct.retry.multiplier=1 # 上次重试间隔的倍数 spring.rabbitmq.listener.direct.retry.stateless=true # 重试是否有状态 spring.rabbitmq.listener.simple.acknowledge-mode= # 确认模式：auto / manual / none spring.rabbitmq.listener.simple.auto-startup=true # 是否在应用启动时自动启动容器 spring.rabbitmq.listener.simple.concurrency= # 监听器最小线程数 spring.rabbitmq.listener.simple.default-requeue-rejected= # 默认情况下，拒收的消息是否重新排队 spring.rabbitmq.listener.simple.idle-event-interval= # 空闲容器事件发布的频率 spring.rabbitmq.listener.simple.max-concurrency= # 监听器最大线程数 spring.rabbitmq.listener.simple.missing-queues-fatal=true # 如果容器声明的队列在 broker 上不可用，是否失败； 如果在运行时删除队列，容器是否停止 spring.rabbitmq.listener.simple.prefetch= # 预加载的消息数量 spring.rabbitmq.listener.simple.retry.enabled=false # 是否启用发布重试 spring.rabbitmq.listener.simple.retry.initial-interval=1000ms # 两次重试时间间隔 spring.rabbitmq.listener.simple.retry.max-attempts=3 # 最大重试次数 spring.rabbitmq.listener.simple.retry.max-interval=10000ms # 最长重试时间 spring.rabbitmq.listener.simple.retry.multiplier=1 # 上次重试间隔的倍数 spring.rabbitmq.listener.simple.retry.stateless=true # 重试是否有状态 spring.rabbitmq.listener.simple.transaction-size= # 确认模式为 auto 时，在 acks 之间处理的消息数. 如果大于预加载的数量，则预加载的数量增加到此值 rabbitmq listener 类型有两种：simple 和 direct，二者有什么区别呢？ DirectMessageListenerContainer 注释如下： The {@code SimpleMessageListenerContainer} is not so simple. Recent changes to the rabbitmq java client has facilitated a much simpler listener container that invokes the listener directly on the rabbit client consumer thread. There is no txSize property - each message is acked (or nacked) individually. 其他设置 spring.rabbitmq.dynamic=true # 是否创建 AmqpAdmin bean spring.rabbitmq.requested-heartbeat= # 请求心跳超时时间. 设置为 0 代表没有，如果未指定时间后缀，则默认使用秒 Spring Boot RabbitMQ 队列属性详解 属性名称 属性说明 Durable 代表该队列是否持久化至硬盘（若要使队列中消息不丢失，同时也需要将消息声明为持久化 Exclusive 是否声明该队列是否为连接独占，若为独占，连接关闭后队列即被删除 Auto-delete 若没有消费者订阅该队列，队列将被删除 Arguments 可选map类型参数，可以指定队列长度，消息生存时间，镜相设置等 RabbitMQ规定，队列的名字最长不超过UTF-8编码的255字节 RabbitMQ内部的Queue命名规则采用 &quot;amq.&quot;形式，注意不要与此规则冲突 常见问题 1. 声明了一个已经存在的队列？ 如果队列已经存在，再次声明将不会起作用。若原始队列参数和该次声明时不同则会报异常。 2. 队列中消息顺序？ 默认情况下是FIFO，即先进先出，同时也支持发送消息时指定消息的优先级。 3. 队列消息存放位置？ 对于临时消息，RabbitMQ尽量将其存放在内存，当出现内存告警时，MQ会将消息持久化至硬盘。对于持久化消息与Lazy-queues，MQ会先将消息存入硬盘，消费时再取出。 4. 队列中消息的消费？ 默认情况下，MQ会设置消费者的消费确认模式为自动。对于一些重要消息的处理，推荐确认模式改为手动。（nack和reject区别？nack可以一次拒绝多条消息） 5. 队列中消息的消费速度？ 通过Prefetch（通道上最大未确认投递数量）设置消费者每次消费的条数，一般将该值设为1，但他会降低吞吐量。RabbitMQ官网建议的是100-300.（更建议反复试验得到一个表现符合期望的值） 6. 队列中消息状态？ 队列中的消息共有俩种状态，一是准备投递，二是已投递但未确认。队列最大长度？ 声明队列时可以指定最大长度，需要注意的是只限制状态为准备投递的数量，未确认的消息不计算在内。当队列长度超过限制，MQ会根据策略选择丢弃（默认）或者将消息投递进死信队列。 7. 关于死信队列？ 其实更准确的说法是死信交换机，提前声明一个交换机，在声明队列时使用“x-dead-letter-exchange”参数（可指定routKey）将队列绑定到该死信交换机。消息有以下情况之一会成为死信：被reject或者nack，消息超过生存时间，队列长度超过限制。 8. 关于不能路由到队列的消息？ 这个和上面一样，其实不算Queue系列而是Exchange。针对消息无法路由到队列的情况MQ提供了Alternate Exchange处理。声明Exchange时添加args.put(“alternate-exchange”,“my-ae”)参数。即当该交换机存在无法路由的消息时，它将消息发布到AE上，AE把消息路由到绑定在他上面的消息。","categories":[{"name":"中间件","slug":"中间件","permalink":"http://blog.tgyf.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/categories/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.tgyf.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.tgyf.com/tags/RabbitMQ/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/tags/MQ/"}]},{"title":"MQ总结（二）-- MQ里消费到重复数据怎么办？","slug":"Middleware/MQ总结：MQ里消费到重复数据怎么办","date":"2020-02-24T14:46:26.897Z","updated":"2020-02-24T14:46:26.897Z","comments":true,"path":"2020/02/24/Middleware/MQ总结：MQ里消费到重复数据怎么办/","link":"","permalink":"http://blog.tgyf.com/2020/02/24/Middleware/MQ%E6%80%BB%E7%BB%93%EF%BC%9AMQ%E9%87%8C%E6%B6%88%E8%B4%B9%E5%88%B0%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%8A%9E/","excerpt":"","text":"如何保证消息消费时的幂等性？（或：如何保证消息不被重复消费？） 既然是消费消息，那肯定要考虑考虑这三点： 会不会重复消费？ 能不能避免重复消费？ 或者重复消费了也别造成系统异常可以吗？ 大概可能会有哪些重复消费 如rabbitmq、rocketmq、kafka，都有可能会出现消费重复消费的问题，正常.因为这问题通常不是mq自己保证的，是给你保证的.然后我们挑一个kafka来举个例子，说说怎么重复消费吧. kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的offset来继续消费吧. 但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接kill进程了，再重启.这会导致consumer有些消息处理了，但是没来得及提交offset，尴尬了.重启之后，少数消息会再次消费一次. 其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性. 怎么保证消息队列消费的幂等性 其实还是得结合业务来思考，这里给几个思路： 比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧 比如你是写redis，那没问题了，反正每次都是set，天然幂等性 比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis.如果消费过了，那你就别处理了，保证别重复处理相同的消息即可. 还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据 如何保证MQ的消费是幂等性的，需要结合具体的业务来看","categories":[{"name":"中间件","slug":"中间件","permalink":"http://blog.tgyf.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/categories/MQ/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/tags/MQ/"},{"name":"一些思考","slug":"一些思考","permalink":"http://blog.tgyf.com/tags/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"}]},{"title":"MQ总结（一）-- 如果MQ挂了怎么办?","slug":"Middleware/MQ总结：如果MQ挂了怎么办","date":"2020-02-24T14:25:38.624Z","updated":"2020-02-24T14:25:38.625Z","comments":true,"path":"2020/02/24/Middleware/MQ总结：如果MQ挂了怎么办/","link":"","permalink":"http://blog.tgyf.com/2020/02/24/Middleware/MQ%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A6%82%E6%9E%9CMQ%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/","excerpt":"","text":"如何保证消息队列的高可用？ 如果MQ挂了，导致几个小时系统不可用，公司损失几千万，Team背锅，你闹的祸，你老大帮你一起背锅. 所以说，在非常核心的系统里，一定要考虑引入MQ所导致系统可用性降低的问题. RabbitMQ的高可用性 Rabbitmq有三种模式：单机模式，普通集群模式，镜像集群模式. RabbitMQ – 单机模式 就是demo级别的，一般就是你本地启动了玩玩儿的，用于本地开发环境，没人在生产环境用单机模式. RabbitMQ – 普通集群模式 就是在多台机器上启动多个rabbitmq实例，每个机器启动一个.但是你创建的queue，只会放在一个rabbtimq实例上，但是每个实例都同步queue的元数据.完了你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来. 缺点： 这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群.因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈. 如果那个放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据. 总结： 所以综上所述这就没有什么所谓的高可用性可言了，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个queue的读写操作. RabbitMQ – 镜像集群模式 这种模式，才是所谓的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步. 优点： 你任何一个机器宕机了，没事儿，别的机器都可以用. 缺点： 第一 这个性能开销太大了，消息同步所有机器，导致网络带宽压力和消耗很重！ 第二 这么玩，就没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue. 怎么开启镜像集群模式? rabbitmq有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候可以要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了. kafka的高可用性 kafka最基本的架构认识 多个broker组成，每个broker是一个节点；你创建一个topic，这个topic可以划分为多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据. 这就是天然的分布式消息队列，就是说一个topic的数据，是分散放在多个机器上的，每个机器就放一部分数据. 实际上rabbitmq之类的，并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论怎么玩儿，rabbitmq一个queue的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个queue的完整数据. kafka的HA机制 kafka 0.8以前，是没有HA机制的，就是任何一个broker宕机了，那个broker上的partition就废了，没法写也没法读，没有什么高可用性可言. kafka 0.8以后，提供了HA机制，就是replica副本机制.每个partition的数据都会同步到吉他机器上，形成自己的多个replica副本.然后所有replica会选举一个leader出来，那么生产和消费都跟这个leader打交道，然后其他replica就是follower.写的时候，leader会负责把数据同步到所有follower上去，读的时候就直接读leader上数据即可.只能读写leader？很简单，要是你可以随意读写每个follower，那么就要care数据一致性的问题，系统复杂度太高，很容易出问题.kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才可以提高容错性. 就有所谓的高可用性了，因为如果某个broker宕机了，没事儿，那个broker上面的partition在其他机器上都有副本的，如果这上面有某个partition的leader，那么此时会重新选举一个新的leader出来，大家继续读写那个新的leader即可.这就有所谓的高可用性了. 写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己主动从leader来pull数据.一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有follower的ack之后，就会返回写成功的消息给生产者.（当然，这只是其中一种模式，还可以适当调整这个行为） 消费的时候，只会从leader去读，但是只有一个消息已经被所有follower都同步成功返回ack的时候，这个消息才会被消费者读到.","categories":[{"name":"中间件","slug":"中间件","permalink":"http://blog.tgyf.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/categories/MQ/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"http://blog.tgyf.com/tags/MQ/"},{"name":"一些思考","slug":"一些思考","permalink":"http://blog.tgyf.com/tags/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"}]},{"title":"关于中间件的一些思考","slug":"Middleware/ThinkInMiddleware","date":"2020-02-24T14:25:33.344Z","updated":"2020-02-24T14:25:33.344Z","comments":true,"path":"2020/02/24/Middleware/ThinkInMiddleware/","link":"","permalink":"http://blog.tgyf.com/2020/02/24/Middleware/ThinkInMiddleware/","excerpt":"","text":"为什么有这篇文章？ 在项目团队中往往有这样一些人，并不知道自己为什么要在项目用中间件这个东西.其实说白了，就是为了用而用.或者是别人设计的架构，从头到尾没有思考过.这些人给我的映像就是木头木脑的干呆活儿，一本正经的挖坑.为了避免以后团队中出现这类型人，所以有了这篇思维导图型的文章. 1.为什么使用这个类型中间件？ 其实就是这个中间件都有哪些使用场景，然后在项目里具体是什么场景，这个业务场景有个什么技术挑战，如果不用可能会很麻烦，但是你现在用了之后带给了你很多的好处. 2.有什么优点和缺点？原理是怎样的？ 引入中间件之后会不会有什么坏处？要是没考虑过这个，那盲目弄个中间件进系统里，后面出了问题是不是当事人就溜了，这就是给公司后来接盘的人留坑.要是没考虑过引入一个技术可能存在的弊端和风险，这类哥们，基本可能就是挖坑型选手. 3.同类型产品调研对比，分别适合哪些场景？ 中间件没有绝对的好坏，但是就是看用在哪个场景可以扬长避短，利用其优势，规避其劣势. 如果去设计个什么系统，在里面用一些技术，可能都没考虑过选型，最后选的技术可能并不一定合适，一样是留坑.","categories":[{"name":"中间件","slug":"中间件","permalink":"http://blog.tgyf.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"一些思考","slug":"一些思考","permalink":"http://blog.tgyf.com/tags/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"}]},{"title":"Hexo主题pure使用指南","slug":"Blog/Hexo主题pure使用指南","date":"2020-02-23T15:12:34.123Z","updated":"2020-02-23T15:12:34.123Z","comments":true,"path":"2020/02/23/Blog/Hexo主题pure使用指南/","link":"","permalink":"http://blog.tgyf.com/2020/02/23/Blog/Hexo%E4%B8%BB%E9%A2%98pure%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"123预览地址: https://blog.cofess.com项目地址: https://github.com/cofess/hexo-theme-pure中文使用文档: https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md 使用前请操作 使用该主题前, 请先复制 theme/pure/_source/ 目录下的所有内容到 blog path/source/ 目录下 原因在于该目录下有建好的菜单 categories(分类)、tags(标签)、repository(项目)、books(书单)、links(友链)、about(关于)页面 当你使用自动生成分类、标签，展示github项目时 文章目录索引 在文章详情页, 展示一个文章目录 主题配置文件中开启配置: 12config toc: true # 是否开启文章章节目录导航 在文章顶部将该文章开启索引, 如: 12345678910111213---title: Hexo主题pure使用指南date: 2019-11-05 14:34:15tags: - hexo主题categories:- hexotoc: true # 是否启用内容索引sidebar: none # 是否启用sidebar侧边栏，none：不启用--- 侧边栏 主题配置项中, 侧边栏可以如下配置: 123456789101112131415# 侧边栏sidebar: right# 侧边栏启用哪些模块widgets: - board # 公告 - category # 分类 - tag # 标签 - tagcloud # 标签云 - archive # 归档 - recent_posts # 最近文章# 归档列表的展示方式archive_type: 'monthly' # 归档方式: yearly | monthlyshow_count: true # 显示每个归档的文章总数 图集 在文章详情页中, 涉及的图片可以使用图集功能, 在点击一张图片时, 放大图片. 主题的图册公告是使用fancybox实现, 可以参照github 1234# Fancybox# 图集功能fancybox: true 展示github项目 在左侧菜单项目中, 点击展示自己的github项目 在主题配置文件中 _config.yml 修改, 请配置自己github用户名 123github: username: caoruiy # github用户名 新建repository页面: 12&gt; hexo new repository 你也可以直接复制 theme/pure/_source/ 目录下 repository文件夹 到 博客根目录/source/ 目录下 将文件内容修改为: 1234567---title: Repositorieslayout: repositorycomments: falsesidebar: none--- 关键内容为 layout: repository, 包含该属性才可以展示github项目 评论功能 主题集成了disqus、友言、来必力、gitment、gitalk评论系统，选择其中一种即可 你可以在主题配置文件中修改评论工具 123comment: type: valine # 启用哪种评论系统 Valine 一个无后端的评论框工具, 其依赖于 Leancloud 开发, 所以使用前需要先注册 Leancloud 账号 如何开始? 你可以从 Valine-快速开始 教程开始, 教程包含了一步一步的指引教程. Valine配置项 主题valine评论框提供了以下配置项 1234567891011121314valine: # Valine官方地址: https://valine.js.org appid: # 你的 leancloud 应用 appid appkey: # 你的 leancloud 应用 appkey notify: true # 是否开始评论邮件提醒, 教程: https://github.com/xCss/Valine/wiki verify: false # 是否开始验证码功能, 开始邮件提醒会自动开启验证码功能 placeholder: 说点什么... # 输入框默认内容 avatar: mm # 头像展示方式, 具体设置项教程: https://valine.js.org/configuration.html#avatar meta: nick,mail,link # 自定义评论信息 pageSize: 10 # 评论列表分页 lang: zh-cn, # 多语言支持 zh-cn | en visitor: true # 文章阅读量统计: https://valine.js.org/visitor.html highlight: true # 代码高亮 recordIP: true # 记录评论者的IP 关于邮件提醒: 只有在回复评论时, 并且填写了邮箱的评论才会收到回复提醒 关于文章阅读量统计: 开启阅读量统计, 会在详情页标题下展示阅读量数据 搜索功能 主题提供内置的搜索功能和百度搜索, 百度搜索就是使用百度的SEO搜索, 个人觉得不是很实用, 不建议开启. 在主题配置文件 _config.yml 中配置: 12345# Searchsearch: insight: true # 在使用搜索功能前, 你需要安装 `hexo-generator-json-content` baidu: false # 使用百度搜索前, 你必须禁用其他所有的搜索功能 内置搜索 使用搜索功能前需要先安装: 12npm i -S hexo-generator-json-content 项目地址: https://github.com/alexbruno/hexo-generator-json-content 在你运行 hexo g 或者 hexo s 时生效，在 hexo g 生成站点时, 会在根目录下生成 content.json 该文件内容即为搜索内容。 你可以对搜索内容进行自定义的配置， 只要在 _config.yml 中配置 jsonContent即可: 1234567891011121314151617181920# 示例: 隐藏分类和标签的搜索jsonContent: dateFormat: DD/MM/YYYY posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false author: false 文章阅读数量统计 主题提供 不蒜子 和 基于 leancloud 的统计 但是经过验证, 发现基于leancloud的统计不生效, 不知原因, 实现等效的方法就是: 评论框使用valine评论框(主题已经内置), 同时开启 visitor: true 配置项项即可 字数统计&amp;阅读时长 主题内置了该功能, 使用前需要先安装插件: 12npm i -S hexo-wordcount 主题配置文件中, 开启设置即可: 123456# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 友情链接 复制 theme/pure/_source/ 目录下 links文件夹 到 blog path/source/ 目录下 在 hexo 目录下的 source 文件夹内创建一个名为 _data（禁止改名）的文件夹。 然后在文件内创建一个名为 links.yml 的文件,在其中添加相关数据即可。 单个友情链接的格式为： 12345Name: link: http://example.com avatar: http://example.com/avatar.png desc: \"这是一个描述\" 添加多个友情链接，我们只需要根据上面的格式重复填写即可。 将 Name 改为友情链接的名字，例如 Cofess。 http://example.com 为友情链接的地址。 http://example.com/avatar.png 为友情链接的头像。 这是一个描述 为友情链接描述。","categories":[{"name":"应用部署","slug":"应用部署","permalink":"http://blog.tgyf.com/categories/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://blog.tgyf.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"搭建个人博客hexo详细步骤","slug":"Blog/搭建个人博客hexo详细步骤","date":"2020-02-23T14:44:47.683Z","updated":"2020-02-23T14:44:47.683Z","comments":true,"path":"2020/02/23/Blog/搭建个人博客hexo详细步骤/","link":"","permalink":"http://blog.tgyf.com/2020/02/23/Blog/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2hexo%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start 第一步：下载安装Git与node.js Git下载地址 node.js下载地址 第二步：安装hexo 1$ npm install -g hexo 这里如果地址被“墙”，可以参考这篇文章的“安装Hexo”部分 第三步：初始化Hexo 创建文件夹（我的是在F盘创建的Hexo） 在Hexo文件夹下，右键运行Git Bash，输入命令：hexo init 在_config.yml,进行基础配置 第四步：本地部署博客 分别输入 如下命令： 12hexo ghexo s 更多hexo常用命令","categories":[{"name":"应用部署","slug":"应用部署","permalink":"http://blog.tgyf.com/categories/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://blog.tgyf.com/tags/%E5%8D%9A%E5%AE%A2/"}]}]}